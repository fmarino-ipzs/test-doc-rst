<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Documentation</title>
  <!-- Basic styling for the page with clean, simple interface -->
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      border-bottom: 1px solid #eaecef;
      padding-bottom: 10px;
    }
    h2 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-size: 1.5em;
    }
    .section {
      margin-bottom: 30px;
    }
    .language-link {
      display: inline-block;
      margin-right: 15px;
      padding: 5px 10px;
      background: #f1f8ff;
      border-radius: 3px;
      text-decoration: none;
      color: #0366d6;
    }
    .language-link:hover {
      background: #ddeeff;
    }
    .item {
      margin: 10px 0;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 3px;
    }
    .item-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .no-item {
      color: #666;
      font-style: italic;
    }
    .debug-panel {
      margin-top: 20px;
      padding: 10px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
  </style>
  <script>
    // When the DOM is fully loaded, start detecting the directory structure
    document.addEventListener('DOMContentLoaded', function() {
      fetchDirectoryStructure();
    });

    // Enable debug mode if ?debug=true is in the URL
    const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === 'true';
    
    // Log function that only works in debug mode
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
        
        // Also append to debug panel if it exists
        const debugPanel = document.getElementById('debug-panel');
        if (debugPanel) {
          debugPanel.style.display = 'block';
          const message = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
          ).join(' ');
          debugPanel.innerHTML += `<div>${message}</div>`;
        }
      }
    }

    async function fetchDirectoryStructure() {
      try {
        // References to DOM elements that will be populated
        const sections = {
          versioneCorrente: document.getElementById('versione-corrente-content'),
          releases: document.getElementById('releases-content'),
          prs: document.getElementById('prs-content')
        };
        
        /**
         * Gets the directory structure by intelligently scanning the page components
         * This uses only smart scanning techniques, no brute force
         */
        async function getDirectoriesFromLinks() {
          const knownDirs = {
            'versione-corrente': ['versione-corrente'],
            'releases': [], 
            'prs': []
          };
          
          try {
            // Get directories by inspecting the DOM and using XHR-based directory detection
            await scanDirectoriesFromDOM(knownDirs);
            
            // Try a secondary approach: scan the page tree with the data we can access
            if (knownDirs.releases.length === 0 && knownDirs.prs.length === 0) {
              await scanDirectoriesFromIndexPages(knownDirs);
            }
            
            debugLog('Found directories:', knownDirs);
          } catch (e) {
            console.warn('Error scanning directories:', e);
          }
          
          return knownDirs;
        }

        /**
         * Scans directories by looking at page elements and links
         */
        async function scanDirectoriesFromDOM(knownDirs) {
          debugLog('Scanning directories from DOM...');
          
          // 1. Look for existing links in the page that might point to directories
          const links = document.querySelectorAll('a[href]');
          const dirPaths = new Set();
          
          links.forEach(link => {
            const href = link.getAttribute('href');
            // Check for links that might point to our directory structure
            if (href) {
              // Releases pattern detection
              const releaseMatch = href.match(/releases\/([^\/]+)/);
              if (releaseMatch && releaseMatch[1]) {
                dirPaths.add(['releases', releaseMatch[1]]);
              }
              
              // PRs pattern detection
              const prMatch = href.match(/prs\/([^\/]+)/);
              if (prMatch && prMatch[1]) {
                dirPaths.add(['prs', prMatch[1]]);
              }
            }
          });
          
          // 2. Check each potential directory path
          for (const [dirType, dirName] of dirPaths) {
            if (await checkDirectoryExists(`${dirType}/${dirName}`)) {
              knownDirs[dirType].push({name: dirName});
              debugLog(`Found ${dirType}/${dirName} from page links`);
            }
          }
        }

        /**
         * Uses a more advanced technique to scan for directory listings
         * by fetching known index locations
         */
        async function scanDirectoriesFromIndexPages(knownDirs) {
          debugLog('Scanning directories from index pages...');
          
          // Directories we want to scan
          const baseDirectories = ['releases', 'prs'];
          
          for (const baseDir of baseDirectories) {
            // Try to fetch the directory listing
            const html = await fetchDirectoryIndex(baseDir);
            
            if (html) {
              // We found a directory index! Extract directory names
              const directoryNames = extractDirectoryNamesFromHTML(html, baseDir);
              debugLog(`Found directory index for ${baseDir}, extracted:`, directoryNames);
              
              // Verify each directory actually exists by checking for index files
              for (const dirName of directoryNames) {
                if (await checkDirectoryExists(`${baseDir}/${dirName}`)) {
                  knownDirs[baseDir].push({name: dirName});
                  debugLog(`Verified ${baseDir}/${dirName} exists`);
                }
              }
            } else {
              // Try an alternative approach - check for /dir/ pattern in current document
              debugLog(`No directory index found for ${baseDir}, trying HTML structure analysis`);
              const foundDirs = analyzeHTMLStructure(document.documentElement.innerHTML, baseDir);
              
              for (const dirName of foundDirs) {
                if (await checkDirectoryExists(`${baseDir}/${dirName}`)) {
                  knownDirs[baseDir].push({name: dirName});
                  debugLog(`Found ${baseDir}/${dirName} from HTML analysis`);
                }
              }
            }
          }
        }

        /**
         * Advanced method to extract directory names from raw HTML
         * using regex patterns commonly found in directory listings
         */
        function analyzeHTMLStructure(html, baseDir) {
          const foundDirs = new Set();
          
          // Common patterns for directory links
          const patterns = [
            // GitHub Pages directory pattern
            new RegExp(`href=["']\\/${baseDir}\\/([^\\/"\\']+)`, 'g'),
            // Common directory index pattern
            new RegExp(`href=["']([^\\/"\\']+)\\/["']`, 'g'),
            // Alternative pattern with path
            new RegExp(`${baseDir}\\/([^\\/\\s"']+)`, 'g')
          ];
          
          for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(html)) !== null) {
              if (match[1] && !match[1].includes('.') && !match[1].includes('?')) {
                foundDirs.add(match[1]);
              }
            }
          }
          
          return [...foundDirs];
        }

        /**
         * Tries to fetch a directory index page
         * @returns {string|null} HTML content or null if not found
         */
        async function fetchDirectoryIndex(path) {
          try {
            // Try different possible index endpoints
            const endpoints = ['', 'index.html'];
            
            for (const endpoint of endpoints) {
              const url = `${path}/${endpoint}`;
              debugLog(`Fetching directory index from: ${url}`);
              
              try {
                const response = await fetch(url, { 
                  method: 'GET',
                  headers: { 'Accept': 'text/html' }
                });
                
                if (response.ok) {
                  const contentType = response.headers.get('content-type');
                  if (contentType && contentType.includes('text/html')) {
                    const html = await response.text();
                    
                    // Check if this looks like a directory listing
                    if (html.includes('<a href') && (
                        html.includes('Directory') || 
                        html.includes('Index of') || 
                        html.includes('folder') ||
                        html.match(/href=["'][^"']+\/["']/)
                      )) {
                      debugLog(`Found potential directory listing at ${url}`);
                      return html;
                    }
                  }
                }
              } catch (e) {
                debugLog(`Error fetching ${url}:`, e.message);
              }
            }
            
            return null;
          } catch (error) {
            debugLog(`Error in fetchDirectoryIndex: ${error.message}`);
            return null;
          }
        }

        /**
         * Extracts directory names from HTML directory listings
         * @param {string} html - HTML content
         * @param {string} baseDir - Base directory ('releases' or 'prs')
         * @returns {string[]} - Directory names
         */
        function extractDirectoryNamesFromHTML(html, baseDir) {
          if (!html) return [];
          
          const directories = new Set();
          
          // Method 1: DOM parsing
          try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Get all links that look like directories
            const links = doc.querySelectorAll('a');
            
            links.forEach(link => {
              const href = link.getAttribute('href');
              // Common patterns for directory links
              if (href && (
                  href.endsWith('/') || 
                  link.textContent.includes('Directory') ||
                  link.parentElement?.textContent.includes('Directory') ||
                  link.classList.contains('directory')
                )) {
                // Clean up the directory name
                let dirName = href.replace(/\/+$/, ''); // Remove trailing slashes
                dirName = dirName.split('/').pop(); // Get the last path component
                
                // Skip parent directory links and empty names
                if (dirName && dirName !== '..' && dirName !== '.' && 
                    !dirName.includes('.') && !dirName.includes('?')) {
                  directories.add(dirName);
                }
              }
            });
          } catch (e) {
            debugLog('Error parsing HTML:', e.message);
          }
          
          // Method 2: Regex patterns (backup method)
          // Look for href="dirname/" patterns
          const regex = new RegExp(`href=["']([^"'/?]+)\\/?["']`, 'g');
          let match;
          while ((match = regex.exec(html)) !== null) {
            const dirName = match[1];
            if (dirName && dirName !== '..' && dirName !== '.' && 
                !dirName.includes('.') && !dirName.includes('?')) {
              directories.add(dirName);
            }
          }
          
          // Method 3: Specific pattern for the given base directory
          const specificRegex = new RegExp(`${baseDir}\\/([^\\/\\s"'.?]+)`, 'g');
          while ((match = specificRegex.exec(html)) !== null) {
            if (match[1] && match[1] !== '..' && match[1] !== '.') {
              directories.add(match[1]);
            }
          }
          
          return [...directories];
        }

        /**
         * Checks if a directory exists by testing if it contains index files
         */
        async function checkDirectoryExists(path) {
          try {
            // Check if either Italian or English index exists
            return (await checkForIndexFile(path, 'it')) || (await checkForIndexFile(path, 'en'));
          } catch (error) {
            return false;
          }
        }
        
        /**
         * Tests if an index.html file exists at the specified path/language
         */
        async function checkForIndexFile(path, lang) {
          try {
            // Use HEAD request to check existence without downloading content
            const url = `${path}/${lang}/index.html`;
            
            // Only log in verbose debug mode to avoid console flooding
            if (DEBUG_MODE) {
              debugLog(`Checking file: ${url}`);
            }
            
            const response = await fetch(url, { method: 'HEAD' });
            const exists = response.ok;
            
            if (exists && DEBUG_MODE) {
              debugLog(`File exists: ${url}`);
            }
            
            return exists;
          } catch (error) {
            return false;
          }
        }
        
        /**
         * Populates the Current Version section
         */
        async function populateCurrentVersion() {
          // Check if Italian or English versions exist
          const itExists = await checkForIndexFile('versione-corrente', 'it');
          const enExists = await checkForIndexFile('versione-corrente', 'en');
          
          debugLog('Current version status:', { italian: itExists, english: enExists });
          
          let html = '';
          if (itExists || enExists) {
            html += `<div class="item">`;
            if (itExists) {
              html += `<a class="language-link" href="versione-corrente/it/index.html">Italiano</a>`;
            }
            if (enExists) {
              html += `<a class="language-link" href="versione-corrente/en/index.html">English</a>`;
            }
            html += `</div>`;
          } else {
            html = `<p class="no-item">No current version available</p>`;
          }
          
          sections.versioneCorrente.innerHTML = html;
        }
        
        /**
         * Populates the Releases section
         */
        async function populateReleases() {
          const dirs = await getDirectoriesFromLinks();
          const releases = dirs.releases;
          
          debugLog('Populating releases:', releases);
          
          let html = '';
          
          if (releases.length > 0) {
            // Sort releases by semantic version (newest first)
            releases.sort((a, b) => b.name.localeCompare(a.name, undefined, { numeric: true, sensitivity: 'base' }));
            
            for (const release of releases) {
              const itExists = await checkForIndexFile(`releases/${release.name}`, 'it');
              const enExists = await checkForIndexFile(`releases/${release.name}`, 'en');
              
              debugLog(`Release ${release.name} status:`, { italian: itExists, english: enExists });
              
              html += `
              <div class="item">
                <div class="item-title">${release.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="releases/${release.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="releases/${release.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No releases available</p>`;
          }
          
          sections.releases.innerHTML = html;
        }
        
        /**
         * Populates the Pull Requests section
         */
        async function populatePRs() {
          const dirs = await getDirectoriesFromLinks();
          const prs = dirs.prs;
          
          debugLog('Populating PRs:', prs);
          
          let html = '';
          
          if (prs.length > 0) {
            // Sort PRs by number (newest first)
            prs.sort((a, b) => {
              const numA = parseInt(a.name.replace(/^pr/i, ''), 10) || 0;
              const numB = parseInt(b.name.replace(/^pr/i, ''), 10) || 0;
              return numB - numA;
            });
            
            for (const pr of prs) {
              const itExists = await checkForIndexFile(`prs/${pr.name}`, 'it');
              const enExists = await checkForIndexFile(`prs/${pr.name}`, 'en');
              
              debugLog(`PR ${pr.name} status:`, { italian: itExists, english: enExists });
              
              html += `
              <div class="item">
                <div class="item-title">${pr.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="prs/${pr.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="prs/${pr.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No pull requests available</p>`;
          }
          
          sections.prs.innerHTML = html;
        }
        
        // Load all sections in parallel for better performance
        await Promise.all([
          populateCurrentVersion(),
          populateReleases(),
          populatePRs()
        ]).catch(error => {
          console.error('Error loading sections:', error);
          document.getElementById('error-message').style.display = 'block';
          document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
        });
        
      } catch (error) {
        console.error('General error:', error);
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
      }
    }
  </script>
</head>
<body>
  <!-- Main page title -->
  <h1>Project Documentation</h1>
  
  <!-- Error message container (hidden by default) -->
  <div id="error-message" style="display: none; color: red; padding: 10px; background: #ffeeee; border: 1px solid #ffcccc; margin-bottom: 20px;"></div>
  
  <!-- Current Version section -->
  <div class="section">
    <h2>Current Version</h2>
    <div id="versione-corrente-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Releases section -->
  <div class="section">
    <h2>Releases</h2>
    <div id="releases-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Pull Requests section -->
  <div class="section">
    <h2>Pull Requests</h2>
    <div id="prs-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Debug panel (only visible in debug mode) -->
  <div id="debug-panel" class="debug-panel">
    <h3>Debug Log</h3>
  </div>
  
  <!-- Page footer with last update timestamp -->
  <footer style="margin-top: 50px; color: #666; font-size: 0.9em; text-align: center; border-top: 1px solid #eaecef; padding-top: 20px;">
    Dynamically generated - Last update: <span id="last-update-date"></span>
    <script>
      document.getElementById('last-update-date').textContent = new Date().toLocaleDateString();
    </script>
  </footer>
</body>
</html>