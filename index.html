<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Documentation</title>
  <!-- Basic styling for the page with clean, simple interface -->
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      border-bottom: 1px solid #eaecef;
      padding-bottom: 10px;
    }
    h2 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-size: 1.5em;
    }
    .section {
      margin-bottom: 30px;
    }
    .language-link {
      display: inline-block;
      margin-right: 15px;
      padding: 5px 10px;
      background: #f1f8ff;
      border-radius: 3px;
      text-decoration: none;
      color: #0366d6;
    }
    .language-link:hover {
      background: #ddeeff;
    }
    .item {
      margin: 10px 0;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 3px;
    }
    .item-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .no-item {
      color: #666;
      font-style: italic;
    }
    .debug-panel {
      margin-top: 20px;
      padding: 10px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #0366d6;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  <script>
    // When the DOM is fully loaded, start detecting the directory structure
    document.addEventListener('DOMContentLoaded', function() {
      fetchDirectoryStructure();
    });

    // Enable debug mode if ?debug=true is in the URL
    const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === 'true';
    
    // Log function that only works in debug mode
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
        
        // Also append to debug panel if it exists
        const debugPanel = document.getElementById('debug-panel');
        if (debugPanel) {
          debugPanel.style.display = 'block';
          const message = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
          ).join(' ');
          debugPanel.innerHTML += `<div>${message}</div>`;
        }
      }
    }

    async function fetchDirectoryStructure() {
      try {
        // Start the loading indicators
        document.getElementById('versione-corrente-content').innerHTML = '<div class="loading-spinner"></div> Scanning...';
        document.getElementById('releases-content').innerHTML = '<div class="loading-spinner"></div> Scanning...';
        document.getElementById('prs-content').innerHTML = '<div class="loading-spinner"></div> Scanning...';
        
        // References to DOM elements that will be populated
        const sections = {
          versioneCorrente: document.getElementById('versione-corrente-content'),
          releases: document.getElementById('releases-content'),
          prs: document.getElementById('prs-content')
        };
        
        // Cache for valid subdirectories to reduce network requests
        const validDirectoryCache = new Map();
        
        /**
         * Main function that discovers subdirectories without any assumptions about naming patterns
         * This uses a completely dynamic approach by:
         * 1. Reading root subdirectories from the base path
         * 2. Checking each of them for language subdirectories with index.html files
         * 3. No hardcoded patterns - completely data-driven discovery
         */
        async function discoverSubdirectories() {
          const structure = {
            'versione-corrente': 'versione-corrente',
            'releases': [], 
            'prs': []
          };
          
          debugLog("Starting dynamic directory discovery...");
          
          try {
            // First load the root structure to get the base directories
            const rootDirs = await discoverRootStructure();
            debugLog("Root structure:", rootDirs);
            
            // For each root directory, check for valid subdirectories
            if (rootDirs.includes('versione-corrente')) {
              // Check if versione-corrente is a valid directory
              if (await hasValidLanguageSubdirs('versione-corrente')) {
                structure['versione-corrente'] = 'versione-corrente';
                debugLog("Verified versione-corrente is valid");
              }
            }
            
            if (rootDirs.includes('releases')) {
              // Discover all subdirectories of releases
              const releaseSubdirs = await discoverValidSubdirs('releases');
              structure.releases = releaseSubdirs.map(name => ({ name }));
              debugLog(`Found ${releaseSubdirs.length} release directories:`, releaseSubdirs);
            }
            
            if (rootDirs.includes('prs')) {
              // Discover all subdirectories of prs
              const prSubdirs = await discoverValidSubdirs('prs');
              structure.prs = prSubdirs.map(name => ({ name }));
              debugLog(`Found ${prSubdirs.length} PR directories:`, prSubdirs);
            }
          } catch (e) {
            console.error('Error during dynamic discovery:', e);
          }
          
          return structure;
        }
        
        /**
         * Discovers valid subdirectories of a given parent directory 
         * by first getting all subdirs, and then checking each for language dirs
         */
        async function discoverValidSubdirs(parentDir) {
          // First try to get all subdirectories of the parent
          const allSubdirs = await discoverSubdirNames(parentDir);
          debugLog(`Found ${allSubdirs.length} potential subdirectories in ${parentDir}:`, allSubdirs);
          
          // Then filter only those that have valid language subdirectories
          const validSubdirs = [];
          
          // Create a batch of promises to check all subdirectories in parallel
          const subDirPromises = allSubdirs.map(async (subdir) => {
            const fullPath = `${parentDir}/${subdir}`;
            if (await hasValidLanguageSubdirs(fullPath)) {
              validSubdirs.push(subdir);
              debugLog(`Verified ${fullPath} is valid`);
            }
          });
          
          // Wait for all checks to complete
          await Promise.all(subDirPromises);
          
          return validSubdirs;
        }
        
        /**
         * Checks if a directory has valid language subdirectories (en/it with index.html)
         */
        async function hasValidLanguageSubdirs(dirPath) {
          // Check if at least one language folder contains an index.html
          const itExists = await indexFileExists(`${dirPath}/it/index.html`);
          if (itExists) return true;
          
          const enExists = await indexFileExists(`${dirPath}/en/index.html`);
          return enExists;
        }
        
        /**
         * Discovers the root directory structure using a fetch approach
         * Tries multiple discovery strategies and combines results
         */
        async function discoverRootStructure() {
          const rootDirs = new Set();
          
          // Most reliable approach for GitHub Pages: try direct paths
          // Since you mentioned versione-corrente, prs, and releases specifically
          const knownRootDirs = ['versione-corrente', 'prs', 'releases'];
          
          // Check each known root directory in parallel
          const dirPromises = knownRootDirs.map(async (dir) => {
            // A directory is considered to exist if we can detect subdirectories
            // or if it has valid language subdirectories
            let exists = false;
            
            // Check if the directory has language subdirectories
            if (await hasValidLanguageSubdirs(dir)) {
              exists = true;
              debugLog(`Confirmed ${dir} exists (has language subdirs)`);
            } 
            // Or try to detect subdirectories
            else if (await hasAnyAccessibleSubdirs(dir)) {
              exists = true;
              debugLog(`Confirmed ${dir} exists (has subdirectories)`);
            }
            
            if (exists) {
              rootDirs.add(dir);
            }
          });
          
          // Wait for all directory checks to complete
          await Promise.all(dirPromises);
          
          return Array.from(rootDirs);
        }
        
        /**
         * Checks if a directory has any accessible subdirectories
         * This is used to verify a directory exists without knowing language subdirs
         */
        async function hasAnyAccessibleSubdirs(dirPath) {
          // Try to discover subdirectories
          const subdirs = await discoverSubdirNames(dirPath);
          return subdirs.length > 0;
        }
        
        /**
         * Discovers subdirectory names of a given directory using multiple methods
         * Completely dynamic - doesn't assume any naming pattern
         */
        async function discoverSubdirNames(dirPath) {
          const subdirNames = new Set();
          
          // Try multiple discovery methods and combine results
          try {
            // Method 1: AJAX discovery via <a> tags
            const subdirs1 = await discoverSubdirsViaAjax(dirPath);
            subdirs1.forEach(name => subdirNames.add(name));
            
            // If we found subdirectories, return them
            if (subdirNames.size > 0) {
              return Array.from(subdirNames);
            }
            
            // Method 2: Try to guess some subdirs from the page's HTML and links
            // This is useful if directory listing is disabled but there are references in the page
            const subdirs2 = await discoverSubdirsFromPage(dirPath);
            subdirs2.forEach(name => subdirNames.add(name));
            
            // Method 3: Try to check for metadata files that might reveal directory structure
            const subdirs3 = await discoverSubdirsFromMetadata(dirPath);
            subdirs3.forEach(name => subdirNames.add(name));
          } catch (e) {
            debugLog(`Error discovering subdirectories of ${dirPath}:`, e);
          }
          
          return Array.from(subdirNames);
        }
        
        /**
         * Attempts to discover subdirectories using AJAX
         * This tries to access the directory and parse any links
         */
        async function discoverSubdirsViaAjax(dirPath) {
          try {
            // Try to fetch the directory
            const response = await fetch(dirPath, {
              method: 'GET',
              headers: { 'Accept': 'text/html' },
              cache: 'no-store'
            });
            
            if (response.ok) {
              const html = await response.text();
              
              // If we got a directory listing, parse it
              if (html.includes('<a href') && (
                  html.includes('Index of') || 
                  html.includes('Directory') || 
                  html.match(/href=["'][^"']+\/["']/)
                )) {
                // Use a DOM parser to find directory links
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = doc.querySelectorAll('a[href]');
                
                const subdirs = [];
                links.forEach(link => {
                  const href = link.getAttribute('href');
                  // Look for hrefs that end with / (directory) but aren't parent dirs
                  if (href && href.endsWith('/') && 
                      !href.includes('..') && href !== '../' && 
                      !href.includes(':') && !href.includes('?')) {
                    // Clean the directory name
                    let dirName = href.replace(/\/+$/, '');
                    if (dirName.includes('/')) {
                      dirName = dirName.split('/').pop();
                    }
                    if (dirName && dirName !== '.' && dirName !== '..') {
                      subdirs.push(dirName);
                    }
                  }
                });
                
                debugLog(`Found ${subdirs.length} subdirectories in ${dirPath} via AJAX`);
                return subdirs;
              }
            }
          } catch (e) {
            debugLog(`AJAX directory discovery failed for ${dirPath}:`, e);
          }
          
          return [];
        }
        
        /**
         * Discovers subdirectories by analyzing the current page's HTML
         * for links that might point to subdirectories
         */
        async function discoverSubdirsFromPage(dirPath) {
          const subdirs = new Set();
          
          try {
            // Look for any links in the current page that might point to subdirectories
            // of the given directory
            const regexPattern = new RegExp(`${dirPath}\\/([^\\/\\s"'.]+)`, 'g');
            const html = document.documentElement.innerHTML;
            let match;
            
            while ((match = regexPattern.exec(html)) !== null) {
              if (match[1] && match[1] !== '.' && match[1] !== '..') {
                subdirs.add(match[1]);
              }
            }
            
            // Also check for links in the page
            const links = document.querySelectorAll(`a[href*="${dirPath}/"]`);
            links.forEach(link => {
              const href = link.getAttribute('href');
              const match = href.match(new RegExp(`${dirPath}\\/([^\\/\\s"'.]+)`));
              if (match && match[1] && match[1] !== '.' && match[1] !== '..') {
                subdirs.add(match[1]);
              }
            });
          } catch (e) {
            debugLog(`Page analysis failed for ${dirPath}:`, e);
          }
          
          return Array.from(subdirs);
        }
        
        /**
         * Tries to discover subdirectories from metadata files
         * that might exist in the repository
         */
        async function discoverSubdirsFromMetadata(dirPath) {
          const subdirs = new Set();
          
          try {
            // Try to fetch common metadata files that might list directories
            const metadataFiles = [
              '.index.json',
              'index.json',
              '.directory-list.json',
              'directory-list.json',
              'sitemap.xml'
            ];
            
            for (const file of metadataFiles) {
              try {
                const response = await fetch(`${dirPath}/${file}`, {
                  method: 'GET',
                  cache: 'no-store'
                });
                
                if (response.ok) {
                  const contentType = response.headers.get('content-type');
                  
                  if (contentType && contentType.includes('json')) {
                    // Parse JSON metadata
                    const data = await response.json();
                    
                    // Look for directory listings in various formats
                    if (Array.isArray(data)) {
                      data.forEach(item => {
                        if (typeof item === 'string') {
                          subdirs.add(item);
                        } else if (item && typeof item.name === 'string') {
                          subdirs.add(item.name);
                        }
                      });
                    } else if (data && typeof data === 'object') {
                      // Look for directory listings in objects
                      if (data.directories && Array.isArray(data.directories)) {
                        data.directories.forEach(dir => {
                          if (typeof dir === 'string') {
                            subdirs.add(dir);
                          } else if (dir && typeof dir.name === 'string') {
                            subdirs.add(dir.name);
                          }
                        });
                      }
                    }
                  } else if (contentType && contentType.includes('xml')) {
                    // Parse XML metadata (like sitemaps)
                    const text = await response.text();
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(text, 'text/xml');
                    
                    // Look for URLs in the sitemap
                    const urls = xml.querySelectorAll('url > loc');
                    urls.forEach(url => {
                      const urlText = url.textContent;
                      if (urlText.includes(`/${dirPath}/`)) {
                        const match = urlText.match(new RegExp(`/${dirPath}/([^/]+)`));
                        if (match && match[1]) {
                          subdirs.add(match[1]);
                        }
                      }
                    });
                  }
                }
              } catch (e) {
                // Silently continue to the next file
              }
            }
          } catch (e) {
            debugLog(`Metadata discovery failed for ${dirPath}:`, e);
          }
          
          return Array.from(subdirs);
        }
        
        /**
         * Checks if a file exists using a HEAD request
         * Uses caching to avoid redundant requests
         */
        async function indexFileExists(filePath) {
          // Check cache first
          if (validDirectoryCache.has(filePath)) {
            return validDirectoryCache.get(filePath);
          }
          
          try {
            // Use HEAD request to check existence without downloading content
            const response = await fetch(filePath, { 
              method: 'HEAD',
              cache: 'no-store'
            });
            
            const exists = response.ok;
            
            // Cache the result
            validDirectoryCache.set(filePath, exists);
            
            if (exists && DEBUG_MODE) {
              debugLog(`File exists: ${filePath}`);
            }
            
            return exists;
          } catch (error) {
            validDirectoryCache.set(filePath, false);
            return false;
          }
        }
        
        /**
         * Populates the Current Version section
         */
        async function populateCurrentVersion() {
          // Check if Italian or English versions exist
          const itExists = await indexFileExists('versione-corrente/it/index.html');
          const enExists = await indexFileExists('versione-corrente/en/index.html');
          
          debugLog('Current version status:', { italian: itExists, english: enExists });
          
          let html = '';
          if (itExists || enExists) {
            html += `<div class="item">`;
            if (itExists) {
              html += `<a class="language-link" href="versione-corrente/it/index.html">Italiano</a>`;
            }
            if (enExists) {
              html += `<a class="language-link" href="versione-corrente/en/index.html">English</a>`;
            }
            html += `</div>`;
          } else {
            html = `<p class="no-item">No current version available</p>`;
          }
          
          sections.versioneCorrente.innerHTML = html;
        }
        
        /**
         * Populates the Releases section
         */
        async function populateReleases() {
          const structure = await discoverSubdirectories();
          const releases = structure.releases;
          
          debugLog('Populating releases:', releases);
          
          let html = '';
          
          if (releases.length > 0) {
            // Sort releases by semantic version (newest first)
            releases.sort((a, b) => compareVersions(b.name, a.name));
            
            for (const release of releases) {
              const itExists = await indexFileExists(`releases/${release.name}/it/index.html`);
              const enExists = await indexFileExists(`releases/${release.name}/en/index.html`);
              
              html += `
              <div class="item">
                <div class="item-title">${release.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="releases/${release.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="releases/${release.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No releases available</p>`;
          }
          
          sections.releases.innerHTML = html;
        }
        
        /**
         * Compares semantic versions for sorting
         * Handles various version formats (1.0, v1.0, etc.)
         */
        function compareVersions(a, b) {
          // Handle special named versions
          const specialVersions = ['latest', 'stable', 'beta', 'alpha', 'rc', 'dev'];
          if (specialVersions.includes(a) || specialVersions.includes(b)) {
            if (a === 'latest' || a === 'stable') return -1;
            if (b === 'latest' || b === 'stable') return 1;
            if (a === 'beta') return -1;
            if (b === 'beta') return 1;
            if (a === 'rc') return -1;
            if (b === 'rc') return 1;
            return 0;
          }
          
          // Try to detect version numbers in the string
          const versionRegex = /(\d+(\.\d+)*)/;
          const matchA = a.match(versionRegex);
          const matchB = b.match(versionRegex);
          
          // If both strings contain version numbers, compare them
          if (matchA && matchB) {
            const verA = matchA[1];
            const verB = matchB[1];
            
            // Split into components
            const partsA = verA.split('.').map(p => parseInt(p, 10) || 0);
            const partsB = verB.split('.').map(p => parseInt(p, 10) || 0);
            
            // Ensure both have same number of components
            while (partsA.length < partsB.length) partsA.push(0);
            while (partsB.length < partsA.length) partsB.push(0);
            
            // Compare each component
            for (let i = 0; i < partsA.length; i++) {
              if (partsA[i] !== partsB[i]) {
                return partsA[i] - partsB[i];
              }
            }
            
            return 0;
          }
          
          // If version numbers not found or unable to compare, sort alphabetically
          return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
        }
        
        /**
         * Populates the Pull Requests section
         */
        async function populatePRs() {
          const structure = await discoverSubdirectories();
          const prs = structure.prs;
          
          debugLog('Populating PRs:', prs);
          
          let html = '';
          
          if (prs.length > 0) {
            // Sort PRs by number if they have a number pattern, otherwise sort alphabetically
            prs.sort((a, b) => {
              const numRegex = /\d+/;
              const numA = a.name.match(numRegex);
              const numB = b.name.match(numRegex);
              
              if (numA && numB) {
                return parseInt(numB[0], 10) - parseInt(numA[0], 10);
              }
              
              return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
            });
            
            for (const pr of prs) {
              const itExists = await indexFileExists(`prs/${pr.name}/it/index.html`);
              const enExists = await indexFileExists(`prs/${pr.name}/en/index.html`);
              
              html += `
              <div class="item">
                <div class="item-title">${pr.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="prs/${pr.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="prs/${pr.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No pull requests available</p>`;
          }
          
          sections.prs.innerHTML = html;
        }
        
        // Load all sections in parallel for better performance
        await Promise.all([
          populateCurrentVersion(),
          populateReleases(),
          populatePRs()
        ]).catch(error => {
          console.error('Error loading sections:', error);
          document.getElementById('error-message').style.display = 'block';
          document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
        });
        
      } catch (error) {
        console.error('General error:', error);
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
      }
    }
  </script>
</head>
<body>
  <!-- Main page title -->
  <h1>Project Documentation</h1>
  
  <!-- Error message container (hidden by default) -->
  <div id="error-message" style="display: none; color: red; padding: 10px; background: #ffeeee; border: 1px solid #ffcccc; margin-bottom: 20px;"></div>
  
  <!-- Current Version section -->
  <div class="section">
    <h2>Current Version</h2>
    <div id="versione-corrente-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Releases section -->
  <div class="section">
    <h2>Releases</h2>
    <div id="releases-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Pull Requests section -->
  <div class="section">
    <h2>Pull Requests</h2>
    <div id="prs-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Debug panel (only visible in debug mode) -->
  <div id="debug-panel" class="debug-panel">
    <h3>Debug Log</h3>
  </div>
  
  <!-- Page footer with last update timestamp -->
  <footer style="margin-top: 50px; color: #666; font-size: 0.9em; text-align: center; border-top: 1px solid #eaecef; padding-top: 20px;">
    Dynamically generated - Last update: <span id="last-update-date"></span>
    <script>
      document.getElementById('last-update-date').textContent = new Date().toLocaleDateString();
    </script>
  </footer>
</body>
</html>
