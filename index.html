<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Documentation</title>
  <!-- Basic styling for the page with clean, simple interface -->
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      border-bottom: 1px solid #eaecef;
      padding-bottom: 10px;
    }
    h2 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-size: 1.5em;
    }
    .section {
      margin-bottom: 30px;
    }
    .language-link {
      display: inline-block;
      margin-right: 15px;
      padding: 5px 10px;
      background: #f1f8ff;
      border-radius: 3px;
      text-decoration: none;
      color: #0366d6;
    }
    .language-link:hover {
      background: #ddeeff;
    }
    .item {
      margin: 10px 0;
      padding: 10px;
      background: #f6f8fa;
      border-radius: 3px;
    }
    .item-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .no-item {
      color: #666;
      font-style: italic;
    }
    .debug-panel {
      margin-top: 20px;
      padding: 10px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
  </style>
  <script>
    // When the DOM is fully loaded, start detecting the directory structure
    document.addEventListener('DOMContentLoaded', function() {
      fetchDirectoryStructure();
    });

    // Enable debug mode if ?debug=true is in the URL
    const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === 'true';
    
    // Log function that only works in debug mode
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
        
        // Also append to debug panel if it exists
        const debugPanel = document.getElementById('debug-panel');
        if (debugPanel) {
          debugPanel.style.display = 'block';
          const message = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
          ).join(' ');
          debugPanel.innerHTML += `<div>${message}</div>`;
        }
      }
    }

    async function fetchDirectoryStructure() {
      try {
        // References to DOM elements that will be populated
        const sections = {
          versioneCorrente: document.getElementById('versione-corrente-content'),
          releases: document.getElementById('releases-content'),
          prs: document.getElementById('prs-content')
        };
        
        /**
         * Uses the most direct approach to discover subdirectories:
         * 1. Start with known base directories (prs, releases)
         * 2. Discover subdirectories by checking for language folders with index.html
         */
        async function getDirectoriesFromLinks() {
          const knownDirs = {
            'versione-corrente': ['versione-corrente'],
            'releases': [], 
            'prs': []
          };
          
          try {
            // Discover subdirectories for each known base directory
            const baseDirectories = ['releases', 'prs'];
            
            for (const baseDir of baseDirectories) {
              debugLog(`Scanning ${baseDir} for subdirectories...`);
              
              // Discover subdirectories by trying a fetch on the base dir
              // to get the listing (if directory listing is enabled)
              const dirNamesFromListing = await tryGetDirectoryListingItems(baseDir);
              
              if (dirNamesFromListing.length > 0) {
                debugLog(`Found ${dirNamesFromListing.length} potential subdirectories in ${baseDir} from directory listing`);
                
                // Check each potential subdirectory for language folders with index.html
                for (const dirName of dirNamesFromListing) {
                  if (await isValidSubdirectory(baseDir, dirName)) {
                    knownDirs[baseDir].push({name: dirName});
                    debugLog(`Confirmed ${baseDir}/${dirName} is a valid subdirectory`);
                  }
                }
              } else {
                debugLog(`No directory listing available for ${baseDir}, trying direct discovery...`);
                
                // Since we couldn't get a directory listing, try to discover through direct checks
                const discoveredDirectories = await discoverSubdirectoriesDirectly(baseDir);
                
                if (discoveredDirectories.length > 0) {
                  knownDirs[baseDir] = discoveredDirectories.map(name => ({name}));
                  debugLog(`Discovered ${discoveredDirectories.length} subdirectories in ${baseDir} through direct checks`);
                }
              }
            }
            
            debugLog('Final directory structure:', knownDirs);
          } catch (e) {
            console.warn('Error during directory discovery:', e);
          }
          
          return knownDirs;
        }
        
        /**
         * Tries to get a directory listing and extract item names
         * @param {string} path - Directory path to check
         * @returns {string[]} - Array of item names found in the directory
         */
        async function tryGetDirectoryListingItems(path) {
          try {
            const response = await fetch(path, { 
              method: 'GET',
              headers: { 'Accept': 'text/html' }
            });
            
            if (response.ok) {
              const html = await response.text();
              
              // Check if this looks like a directory listing
              if (html.includes('<a href') && (
                  html.includes('Index of') || 
                  html.includes('Directory listing') ||
                  html.match(/href=["'][^"']+\/["']/)
                )) {
                // Extract directory names using regex
                const dirNames = [];
                const regex = new RegExp(`href=["']([^"'/]+)/?["']`, 'g');
                let match;
                
                while ((match = regex.exec(html)) !== null) {
                  const name = match[1];
                  // Skip parent directories, hidden files, etc.
                  if (name && name !== '..' && name !== '.' && 
                      !name.includes('.') && !name.includes('?')) {
                    dirNames.push(name);
                  }
                }
                
                return dirNames;
              }
            }
            
            return [];
          } catch (error) {
            debugLog(`Error fetching directory listing: ${error.message}`);
            return [];
          }
        }
        
        /**
         * Checks if a directory is a valid subdirectory by verifying it contains language folders with index.html
         * @param {string} baseDir - Base directory (prs or releases)
         * @param {string} dirName - Subdirectory name to check
         * @returns {boolean} - True if it's a valid subdirectory
         */
        async function isValidSubdirectory(baseDir, dirName) {
          const path = `${baseDir}/${dirName}`;
          
          // Check if at least one language folder contains an index.html
          const itExists = await checkForIndexFile(path, 'it');
          const enExists = await checkForIndexFile(path, 'en');
          
          // Directory is valid if at least one language folder has an index.html
          return itExists || enExists;
        }
        
        /**
         * Discovers subdirectories directly by iteratively checking for the existence
         * of index.html files in language folders within potential subdirectories
         * @param {string} baseDir - Base directory (prs or releases)
         * @returns {string[]} - Array of discovered subdirectory names
         */
        async function discoverSubdirectoriesDirectly(baseDir) {
          const discoveredDirs = [];
          
          // For pull requests, check pr1, pr2, pr3, etc.
          if (baseDir === 'prs') {
            // This approach directly checks if common PR patterns exist by looking for index.html files
            for (let i = 1; i <= 100; i++) { // Check up to PR100
              const dirName = `pr${i}`;
              const path = `${baseDir}/${dirName}`;
              
              if (i % 10 === 0) {
                debugLog(`Checking PRs up to ${i}...`);
              }
              
              if (await isValidSubdirectory(baseDir, dirName)) {
                discoveredDirs.push(dirName);
                debugLog(`Found PR: ${dirName}`);
              }
            }
          } 
          // For releases, check common version patterns
          else if (baseDir === 'releases') {
            // Common version patterns to check
            const versionPatterns = [
              // Check numeric versions: 0.1, 0.2, 1.0, 1.1, etc.
              ...generateVersionPatterns(),
              // Named releases
              'latest', 'stable', 'dev', 'beta', 'alpha', 'rc'
            ];
            
            for (const pattern of versionPatterns) {
              if (await isValidSubdirectory(baseDir, pattern)) {
                discoveredDirs.push(pattern);
                debugLog(`Found release: ${pattern}`);
              }
            }
          }
          
          return discoveredDirs;
        }
        
        /**
         * Generates common version patterns to check for releases
         * @returns {string[]} - Array of version patterns
         */
        function generateVersionPatterns() {
          const patterns = [];
          
          // Generate patterns like: 0.1, 0.2, ..., 1.0, 1.1, ...
          for (let major = 0; major <= 5; major++) {
            for (let minor = 0; minor <= 20; minor++) {
              // Skip high minor versions for efficiency except for 0.x
              if (major > 0 && minor > 10) continue;
              
              patterns.push(`${major}.${minor}`);
              
              // Also try with 'v' prefix
              patterns.push(`v${major}.${minor}`);
            }
          }
          
          return patterns;
        }
        
        /**
         * Tests if an index.html file exists at the specified path/language
         */
        async function checkForIndexFile(path, lang) {
          try {
            // Use HEAD request to check existence without downloading content
            const url = `${path}/${lang}/index.html`;
            
            if (DEBUG_MODE && Math.random() < 0.1) { // Only log ~10% of checks
              debugLog(`Checking file: ${url}`);
            }
            
            const response = await fetch(url, { method: 'HEAD' });
            const exists = response.ok;
            
            if (exists && DEBUG_MODE) {
              debugLog(`File exists: ${url}`);
            }
            
            return exists;
          } catch (error) {
            return false;
          }
        }
        
        /**
         * Populates the Current Version section
         */
        async function populateCurrentVersion() {
          // Check if Italian or English versions exist
          const itExists = await checkForIndexFile('versione-corrente', 'it');
          const enExists = await checkForIndexFile('versione-corrente', 'en');
          
          debugLog('Current version status:', { italian: itExists, english: enExists });
          
          let html = '';
          if (itExists || enExists) {
            html += `<div class="item">`;
            if (itExists) {
              html += `<a class="language-link" href="versione-corrente/it/index.html">Italiano</a>`;
            }
            if (enExists) {
              html += `<a class="language-link" href="versione-corrente/en/index.html">English</a>`;
            }
            html += `</div>`;
          } else {
            html = `<p class="no-item">No current version available</p>`;
          }
          
          sections.versioneCorrente.innerHTML = html;
        }
        
        /**
         * Populates the Releases section
         */
        async function populateReleases() {
          const dirs = await getDirectoriesFromLinks();
          const releases = dirs.releases;
          
          debugLog('Populating releases:', releases);
          
          let html = '';
          
          if (releases.length > 0) {
            // Sort releases by semantic version (newest first)
            releases.sort((a, b) => compareVersions(b.name, a.name));
            
            for (const release of releases) {
              const itExists = await checkForIndexFile(`releases/${release.name}`, 'it');
              const enExists = await checkForIndexFile(`releases/${release.name}`, 'en');
              
              debugLog(`Release ${release.name} status:`, { italian: itExists, english: enExists });
              
              html += `
              <div class="item">
                <div class="item-title">${release.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="releases/${release.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="releases/${release.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No releases available</p>`;
          }
          
          sections.releases.innerHTML = html;
        }
        
        /**
         * Compares semantic versions for sorting
         * Handles various version formats (1.0, v1.0, etc.)
         */
        function compareVersions(a, b) {
          // Handle special named versions
          const specialVersions = ['latest', 'stable', 'beta', 'alpha', 'rc', 'dev'];
          if (specialVersions.includes(a) || specialVersions.includes(b)) {
            if (a === 'latest' || a === 'stable') return -1;
            if (b === 'latest' || b === 'stable') return 1;
            if (a === 'beta') return -1;
            if (b === 'beta') return 1;
            if (a === 'rc') return -1;
            if (b === 'rc') return 1;
            return 0;
          }
          
          // Remove 'v' prefix if present
          const cleanA = a.replace(/^v/i, '');
          const cleanB = b.replace(/^v/i, '');
          
          // Split into components
          const partsA = cleanA.split('.').map(p => parseInt(p, 10) || 0);
          const partsB = cleanB.split('.').map(p => parseInt(p, 10) || 0);
          
          // Ensure both have same number of components
          while (partsA.length < partsB.length) partsA.push(0);
          while (partsB.length < partsA.length) partsB.push(0);
          
          // Compare each component
          for (let i = 0; i < partsA.length; i++) {
            if (partsA[i] !== partsB[i]) {
              return partsA[i] - partsB[i];
            }
          }
          
          return 0;
        }
        
        /**
         * Populates the Pull Requests section
         */
        async function populatePRs() {
          const dirs = await getDirectoriesFromLinks();
          const prs = dirs.prs;
          
          debugLog('Populating PRs:', prs);
          
          let html = '';
          
          if (prs.length > 0) {
            // Sort PRs by number (newest first)
            prs.sort((a, b) => {
              const numA = parseInt(a.name.replace(/^pr/i, ''), 10) || 0;
              const numB = parseInt(b.name.replace(/^pr/i, ''), 10) || 0;
              return numB - numA;
            });
            
            for (const pr of prs) {
              const itExists = await checkForIndexFile(`prs/${pr.name}`, 'it');
              const enExists = await checkForIndexFile(`prs/${pr.name}`, 'en');
              
              debugLog(`PR ${pr.name} status:`, { italian: itExists, english: enExists });
              
              html += `
              <div class="item">
                <div class="item-title">${pr.name}</div>`;
              
              if (itExists) {
                html += `<a class="language-link" href="prs/${pr.name}/it/index.html">Italiano</a>`;
              }
              
              if (enExists) {
                html += `<a class="language-link" href="prs/${pr.name}/en/index.html">English</a>`;
              }
              
              html += `</div>`;
            }
          } else {
            html = `<p class="no-item">No pull requests available</p>`;
          }
          
          sections.prs.innerHTML = html;
        }
        
        // Load all sections in parallel for better performance
        await Promise.all([
          populateCurrentVersion(),
          populateReleases(),
          populatePRs()
        ]).catch(error => {
          console.error('Error loading sections:', error);
          document.getElementById('error-message').style.display = 'block';
          document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
        });
        
      } catch (error) {
        console.error('General error:', error);
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'An error occurred while loading the documentation structure.';
      }
    }
  </script>
</head>
<body>
  <!-- Main page title -->
  <h1>Project Documentation</h1>
  
  <!-- Error message container (hidden by default) -->
  <div id="error-message" style="display: none; color: red; padding: 10px; background: #ffeeee; border: 1px solid #ffcccc; margin-bottom: 20px;"></div>
  
  <!-- Current Version section -->
  <div class="section">
    <h2>Current Version</h2>
    <div id="versione-corrente-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Releases section -->
  <div class="section">
    <h2>Releases</h2>
    <div id="releases-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Pull Requests section -->
  <div class="section">
    <h2>Pull Requests</h2>
    <div id="prs-content">
      <p>Loading...</p>
    </div>
  </div>
  
  <!-- Debug panel (only visible in debug mode) -->
  <div id="debug-panel" class="debug-panel">
    <h3>Debug Log</h3>
  </div>
  
  <!-- Page footer with last update timestamp -->
  <footer style="margin-top: 50px; color: #666; font-size: 0.9em; text-align: center; border-top: 1px solid #eaecef; padding-top: 20px;">
    Dynamically generated - Last update: <span id="last-update-date"></span>
    <script>
      document.getElementById('last-update-date').textContent = new Date().toLocaleDateString();
    </script>
  </footer>
</body>
</html>
